# 기억장치

---

## 1️⃣ 기억장치

![stun](/res/memory.png)

### 레지스터❓

- CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치
- CPU와 직접 연결되어 있으므로 연산 속도가 메모리보다 훨씬 빠르다.
- 32비트? 64비트?
    - 명령을 한 번에 처리할 수 있는 레지스터의 비트 수

### 캐시❓

- 컴퓨터 시스템의 성능을 향상시키기 위해 주로 CPU 칩 안에 포함되는 빠르고 작고 비싼 메모리
- 프로그램에서 직접적으로 읽거나 쓸 수 없고 하드웨어의 메모리 관리 시스템(MMU)이 내부적으로 관리
- 메인 메모리에 있는 데이터를 캐시 메모리에 불러와 두고, CPU가 필요한 데이터를 캐시에서 먼저 찾도록 하면 시스템의 성능을 향상시킬 수 있다.

### 주기억장치❓

- 컴퓨터 내부에서 현재 CPU가 처리하고 있는 내용을 저장하고 있는 기억장치
- 비교적 용량이 크고 보조기억장치에 비해 처리 속도가 빠르다
- CPU의 명령에 의해 기억된 장소에 직접 접근하여 읽고 쓸 수 있다.

- ROM (Read Only Memory)
    - 전원이 끊어져도 기록된 데이터들이 소멸되지 않는 비휘발성 메모리
    - 기억된 데이터만 읽기 가능
    - BIOS와 같은 주요 데이터 저장
- RAM (Random Access Memory)
    - 읽고 쓰기가 가능
    - 응용 프로그램, 운영체제 등을 불러와 CPU가 작업할 수 있도록 하는 기억장치
    - 프로그램을 로딩하거나, 데이터를 임시 저장하는데 사용
    - 전원이 끊어지면 데이터가 지워지는 휘발성 메모리

### 보조기억장치❓

- 물리적인 디스크가 연결되어 있는 기억장치
- 주기억장치보다는 느리지만 컴퓨터의 전원을 끄더라도 저장된 데이터가 사라지지 않고 영구적으로 보관가능

- HDD (Hard Disk Driver)
    - 물리적인 디스크를 고속으로 회전시켜 데이터를 저장하는 장치
    - 충격에 약하며, 소음 다소 발생
- SSD (Solid State Driver)
    - 전기적으로 데이터를 저장하는 장치
    - HDD에 비해 속도가 월등히 빠르고 소음 X
    - 전력소모가 적고 경량화, 소형화할 수 있다.
    

💡레지스터, 캐시, 주기억장치의 프로그램과 데이터는 CPU가 직접 액세스 할 수 있으나 보조기억장치에 있는 프로그램이나 데이터는 직접 액세스할 수 없다. 보조기억장치에 있는 데이터는 주기억장치에 적재된 후 CPU에 의해 액세스될 수 있다.

## 2️⃣ 주기억장치 관리

- 보조기억장치의 프로그램이나 데이터를 주기억장치에 `적재시키는 시기, 위치` 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것

- 반입 전략 : 보조기억장치에 보관중인 프로그램이나 데이터를 `언제` 주기억장치로 적재할 것인지 결정하는 전략
    - 요구 반입 : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 `요구할 때 적재`하는 방법
    - 예상 반입 : 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 `미리 예상하여 적재`하는 방법

- 배치 전략 : 새로 반입되는 프로그램이나 데이터를 주기억장치의 `어디에` 위치시킬 것인지 결정하는 전략
    - 최초 적합 : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치
    - 최적 적합 : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치
    - 최악 적합 : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치
    
- 교체 전략 : 주기억장치의 모든 영역이 미리 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략
    - OPT (OPTimal Replacement, 최적 교체)
        - 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
        - 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘
        - 전제조건으로 프로세서가 앞으로 사용할 페이지를 미리 알아야 한다 = 구현이 불가능
        
        ![STUN](/res/OPT.png)
        
    - FIFO (First In First Out)
        - 가장 오래 있었던 페이지를 교체하는 기법
        - 이해하기 쉽고, 프로그래밍 및 설계가 간단하다.
        
        ![stun](/res/FIFO.png)
        
    - LRU (Least Recently Used)
        - 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
        - 최적 알고리즘보다 페이지 교체 횟수는 높지만 FIFO 알고리즘보다 효율적이다.
        
        ![STUN](/res/LRU.png)
        
    - NUR (Not Used Recently)
        - 최근에 사용하지 않은 페이지를 교체하는 기법
        - 최근에 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 전제로 LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다.
        - 최근의 사용 여부를 확인하기 위해 각 페이지마다 참조 비트와 변형비트가 사용
        
    - SCR (Second Chance Replaycement, 2차 기회 교체)
        - 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법
        
    - MFU(Most Frequently Used)
        - 참조 횟수가 가장 많은 페이지를 교체하는기법
        - 참조 회수가 적인 페이지가 최근에 사용된 것이기 때문에 앞으로 사용될 가능성이 높다는 판단
        

## 3️⃣ 주기억장치 할당

- 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지

- 연속 할당 기법 : 프로그램을 주기억장치에 연속으로 할당하는 기법
    - 단일 분할 할당 기법 : `오버레이, 스와핑`
    - 다중 분할 할당 기법 : `고정 분할 할당 기법, 동적 분할 할당 기법`
- 분산 할당 기법 : 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법으로, 페이징 기법과 세그먼테이션 기법으로 나눌 수 있다.

- 단일 분할 할당 기법
    - 주기억장치를 운영체제 영역과 사용자 영역으로 나누어 한 순간에는 오직 한 명의 사용자만이 주기억장치의 사용자 영역을 사용하는 기법
    - 프로그램의 크기가 작을 경우 사용자의 영역이 낭비될 수 있다.
    - 초기에는 주기억장치보다 큰 사용자 프로그램은 실행할 수 없었으나 `오버레이` 기법을 사용하면서 문제를 해결했다.
    
    - 오버레이 기법
        - 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법
        - 보조기억장치에 저장된 하나의 프로그램을 `여러 개의 조각으로 분할`한 후 필요한 조각을 차례로 주기억장치에 적재하여 프로그램을 실행
        - 주기억장치의 공간이 부족하면 주기억장치에 적재된 프로그램의 조각 중 불필요한 조각이 위치한 장소에 새로운 프로그램의 조각을 `중접`하여 적재
    
    - 스와핑 기법
        - 하나의 프로그램 전체를 주 기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법
        - 주기억장치 → 보조기억장치 : Swap Out
        - 보조기억장치 → 주기억장치 : Swap In
    
- 다중 분할 할당 기법
    - 고정 할당 기법 = 정적 할당 기법
        - 프로그램을 할당하기 전에 운영체제가 주기억장치의 사용자 영역을 여러 개의 고정된 크기로 분할하고 준비상태 큐에서 준비중인 프로그램을 각 영역에 할당하여 수행하는 기법
        - 프로그램을 실행하려면 프로그램 전체게 주기억장치에 위치해야함
        - 프로그램이 분할된 영역보다 커서 영역 안에 들어갈 수 없는 경우가 발생할 수 있다.
        - `내부 단편화` 및 `외부 단편화`가 발생하여 주기억장치의 낭비가 심하다.-
        
        💡내부 단편화 : 분할된 영역이 할당될 프로그램의 크기보다 크기때문에 프로그램이 할당된 후 사용되지 않고 남아 있는 공간
        
        💡외부 단편화 : 분할된 영역이 할당될 프로그램의 크기보다 작기 때문에 프로그램이 할당될 수 없어 사용되지 않고 빈 공간으로 남아 있는 분할된 전체 영역
        
    - 가변 할당 기법 = 동적 할당 기법
        - 단편화를 줄이기 위한 것으로, 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분할하는 기법
        - 단편화를 상당 부분 해결할 수 있으나 영역과 영역 사이에 단편화가 발생될 수 있다.
        
    

## 4️⃣ 가상기억장치

- 보조기억장치의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법
- 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용
- 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다.

- 페이징 기법
    - 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 `동일한 크기`로 나눈 후 나눠진 프로그램을 동일하기 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법
    - 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.
    - 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요하다
    - 페이지 맵 테이블 사용으로 `비용이 증가`하고 `처리 속도가 감소`된다.
    
- 세그먼테이션 기법
    - 가상기억장치에 보관되어 있는 프로그램을 `다양한 크기`의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 방법
    - 논리적인 크기로 나눈 단위 = 세그먼트 ( 교유한 이름과 크기를 갖는다.)
    - 기억공간을 절약하기 위해 사용
    - 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블이 필요하다..
    - 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다.