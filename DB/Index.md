# Index

---

## 1️⃣ Index

- Index는 색인이다(책의 목차)
- RDBMS에서 검색 속도를 높이기 위해 사용하는 하나의 기술
- 테이블의 컬럼을 색인화하여 검색시 해당 테이블의 모든 데이터를 확인하는게 아니라 색인화 되어있는 인덱스 파일을 검색하여 검색 속도를 빠르게 한다.
- DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 검색은 빠르지만 추가, 삭제, 수정 시에는 쿼리문 실행 속도가 느려진다.
- Index구조는 tree 구조로 색인화한다
- RDBMS에서는 Balance Search Tree 사용



### B-Tree 인덱스 ( Balance Tree )란❓

- Binary Search Tree의 한계를 극복하고자 나온 자료구조
    - 한쪽 Branch에만 데이터가 몰릴 수 있다.
    - 이 경우, 테이블 복잡도 향상
- 구조적으로는 Binary Search Tree와 비슷하지만 데이터 높이를 자동으로 바로잡아주는 기능 존재
- B+ Tree, B*- Tree



![stun](res/b-tree.png)

- id =3에 대한 정보를 찾는다면 3번의 동작으로 데이터를 찾을 수 있다.
1. Root Node 에서 인덱스 레코드를 확인
2. 0 ~ 5는 페이지 2에 저장되어 있는 것 확인
3. 페이지 2에서 3 ~ 5는 페이지 5에 저장되어 있는 것 확인
4. 페이지 5에서 인덱스 레코드가 3에 해당하는 레코드 주소를 활용하여 데이터를 찾을 수 있다.



### 💡 Index 장점

- 검색과 정렬 속도 향상
- 테이블 행의 고유성을 강화



### 💡 Index 단점

- 사용자가 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
- 추가, 삭제, 수정 시 성능이 떨어진다.
- 데이터 변경 작업이 자주 일어날 경우에는 인덱스를 재작성해야 할 필요가 있기 때문에 성능에 영향을 끼칠 수 있다.



### 🐱 그럼 언제 index를 사용하면 좋을까?

- Where절에서 자주 사용되는 Column
- 외래키가 사용되는 Column
- Join에 자주 사용되는 Column



## 2️⃣ Index 자료구조

### 1. B+-Tree 인덱스 알고리즘

- 일반적으로 사용되는 인덱스 알고리즘
- 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘



### 💡B- Tree

- 데이터가 정렬된 상태로 유지되어 있다
- 한 노드 당 자식 노드가 2개 이상 가능
- 어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다. == 균일성



### 💡B+ Tree

- B- Tree의 확장개념
- 리프 노드에만 key와 data를 저장하고 리프 노드끼리 Linked List로 연결
- 리프 노드에만 데이터를 담아두기 때문에 더 많은 key들을 수용할 수 있다.
    - 하나의 노드에 더 많은 key들을 담을 수 있기 때문에 트리의 높이는 더 낮아진다. == cache hit을 높일 수 있다.
- 스캔 시, 리프 노드에 모든 데이터가 있기 때문에 한 번의 선형 탐색만 하면 된다.
    - B- Tree에 비해 속도가 빠르다.
    
    

### 2. Hash 인덱스 알고리즘

- 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색 지원
- 값을 변형해서 인덱싱하므로, 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다.
- 메모리 기반의 데이터베이스에서 많이 사용
- hash는 동등 연산만 가능





참고한 블로그

------

[https://beelee.tistory.com/37](https://beelee.tistory.com/37)

[https://zorba91.tistory.com/293](https://zorba91.tistory.com/293)